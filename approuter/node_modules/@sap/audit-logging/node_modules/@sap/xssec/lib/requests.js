'use strict';

const constants = require('./constants');
const request = require('request');
const requestRetry = require('requestretry');
const url = require('url');

const errors = require('./errors');

// use environment variable DEBUG with value 'xssec:*' for trace/error messages
const debug = require('debug');
const { exit } = require('process');
const debugTrace = debug('xssec:requests');
const debugError = debug('xssec:requests');

debugError.log = console.error.bind(console);
debugTrace.log = console.log.bind(console);

const X_ZONE_ID_HEADER_NAME = "x-zid";

function getTokenResponseHandler(cb) {
    return function(error, response, body) {
        if (error) {
            if (error.code === 'ETIMEDOUT' && error.connect === true) {
                debugError(fnc + ': HTTP connection timeout.');
            }
            error.statusCode = -1;
            error.description = error.message;
            debugError(error.message);
            debugError(error.stack);
            return cb(error);
        }
        if (response.statusCode !== 200) {
            return cb(new errors.ServerRequestError(response.statusCode + " - " + body, response.statusCode, body));
        }
        var json = null;
        try {
            json = JSON.parse(body);
        } catch (e) {
            e.statusCode = -1;
            e.description = "Could not parse JSON";
            e.content = body;
            return cb(e, null);
        }
        return cb(null, json.id_token || json.access_token || json, json);
    }
}


function _requestToNetwork(fnc, options, cb) {
    debugTrace(fnc + '::HTTP Call with %O', options);
    request(
        options,
        cb
    );
};

function validateParameters(serviceCredentials, cb) {
    // input validation
    if (!serviceCredentials) {
        return new Error('Parameter serviceCredentials is missing but mandatory.');        
    }
    if (!serviceCredentials.clientid) {
        //client_secret will be checked later (only if really needed)
        return new Error('Invalid service credentials: Missing clientid.');
    }
    if (!serviceCredentials.url) {
        return new Error('Invalid service credentials: Missing url.');
    }
    if(!cb || typeof cb !== 'function') {
        return new Error('No callback function provided.');
    }
}


function buildSubdomain(serviceCredentials, subdomain) {
    var urlWithCorrectSubdomain = serviceCredentials.url;
    if (subdomain) {
        var tokenSubdomain = subdomain;
        var tokenRequestSubdomain = null;
        var uaaUrl = url.parse(serviceCredentials.url);
        if (uaaUrl.hostname.indexOf('.') === -1) {
            tokenRequestSubdomain = null;
        } else {
            tokenRequestSubdomain = uaaUrl.hostname.substring(0, uaaUrl.hostname.indexOf('.'));
        }
        if (tokenSubdomain !== null && tokenRequestSubdomain != null && tokenSubdomain !== tokenRequestSubdomain) {
            urlWithCorrectSubdomain = uaaUrl.protocol + "//" + tokenSubdomain + uaaUrl.host.substring(uaaUrl.host.indexOf('.'), uaaUrl.host.size);
        }
    }

    if(serviceCredentials.certificate) {
        urlWithCorrectSubdomain = serviceCredentials.certurl;
    }

    return urlWithCorrectSubdomain;
}

function appendAdditonalAttribites(options, additionalAttributes) {
    if (additionalAttributes !== null) {
        var authorities = { "az_attr" : additionalAttributes };
        options.form.authorities = authorities;
    }
}

function DefaultHeaders(zoneId) {
    var ret = {
        'Accept': 'application/json',
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': constants.USER_AGENT
    };

    if(zoneId) {
        ret[X_ZONE_ID_HEADER_NAME] = zoneId;
    }

    return ret;
}

function buildOptions(serviceCredentials, additionalAttributes, url, grantType, zoneId, timeout) {
    // jwt bearer flow
    var options = {
        method: 'POST',
        url: url + '/oauth/token',
        headers: DefaultHeaders(zoneId),
        form: {
            grant_type: grantType,
            response_type: 'token',
            client_id: serviceCredentials.clientid
        },
        timeout: timeout
    };

    if(serviceCredentials.certificate) {
        options.key = serviceCredentials.key;
        options.cert = serviceCredentials.certificate;
    } else {
        //make sure we have a client_secret set here
        if (!serviceCredentials.clientsecret) {
            throw new Error('Invalid config: Missing clientsecret.');
        }
        
        options.form.client_secret = serviceCredentials.clientsecret;
    }

    appendAdditonalAttribites(options, additionalAttributes);
    
    return options;
}

module.exports.requestOpenIDConfiguration = function (serviceCredentialsUrl, cb) {
    var options = {
        method: 'GET',
        followRedirect: false,
        timeout: 2000,
        url: serviceCredentialsUrl + '/.well-known/openid-configuration',
        headers: {
            'Accept': 'application/json',
            'User-Agent': constants.USER_AGENT
        }
    };

    return _requestToNetwork(".well-known", options, getTokenResponseHandler(cb));
}

module.exports.fetchOIDCKey = function (serviceCredentialsUrl, cb) {
    var options = {
        method: 'GET',
        url: serviceCredentialsUrl,
        followRedirect: false,
        timeout: 2000,
        headers: {
            'Accept': 'application/json',
            'User-Agent': constants.USER_AGENT
        }
    };

    return _requestToNetwork(".oidc-jkws", options, getTokenResponseHandler(cb));
}

module.exports.requestUserToken = function (appToken, serviceCredentials, additionalAttributes, scopes, subdomain, zoneId, cb) {
    //make it backward-compatible (where zoneId is not provided at all)
    if (typeof zoneId === 'function') {
        cb = zoneId;
        zoneId = null;
    }

    var error = validateParameters(serviceCredentials, cb);
    if(error) {
        error.statuscode = 500;
        return cb(error, null);
    }

    const urlWithCorrectSubdomain = buildSubdomain(serviceCredentials, subdomain);

    try {
        // jwt bearer flow
        var options = buildOptions(serviceCredentials, 
            additionalAttributes, 
            urlWithCorrectSubdomain, 
            'urn:ietf:params:oauth:grant-type:jwt-bearer', 
            zoneId,
            10*1000);

        //add Assertion
        options.form.assertion = appToken;

        if (scopes !== null) {
            options.form.scope = scopes;
        }

        return _requestToNetwork("requestUserToken", options, getTokenResponseHandler(cb));            
    } catch(e) {
        //the verification of the serviceCredentials fails
        e.statuscode = 500;
        return cb(e);
    }
}

module.exports.requestClientCredentialsToken = function (subdomain, serviceCredentials, additionalAttributes, zoneId, cb) {
    //make it backward-compatible (where zoneId is not provided at all)
    if (typeof zoneId === 'function') {
        cb = zoneId;
        zoneId = null;
    }

    // input validation
    const error = validateParameters(serviceCredentials, cb);
    if(error) {
        error.statuscode = 500;
        return cb(error, null);
    }

    // adapt subdomain in service url, if necessary
    const urlWithCorrectSubdomain = buildSubdomain(serviceCredentials, subdomain);

    try {
        const options = buildOptions(serviceCredentials, 
            additionalAttributes, 
            urlWithCorrectSubdomain, 
            'client_credentials', 
            zoneId,
            2*1000);

        appendAdditonalAttribites(options, additionalAttributes);
        return _requestToNetwork("requestClientCredentialsToken", options, getTokenResponseHandler(cb));            
    } catch(e) {
        //the verification of the serviceCredentials fails
        e.statuscode = 500;
        return cb(e);
    }        
};

module.exports.fetchKeyFromXSUAA = function (tokenKeyUrl, zid, cb) {
    // try to obtain key from UAA
    var options = {
        url: tokenKeyUrl,
        timeout: 2000,
        headers: {
            "User-Agent": constants.USER_AGENT,
        },
        followRedirect: false,
        maxAttempts: 3,
        retryDelay: 500,
        retryStrategy: requestRetry.RetryStrategies.HTTPOrNetworkError
    };    

    requestRetry.get(options, function (err, response, body) {
        if (err) {
            return cb(err);
        }

        if (response.statusCode !== 200) {
            var error = new Error('Call was not successful. Error Code: ' + response.statusCode + " " + body);
            error.statuscode = response.statusCode;
            error.body = body;
            return cb(error);
        }

        try {
            var json = JSON.parse(body);
            return cb(null, json);
        } catch (e) {
            var error = new Error('Error parsing response from UAA: ' + e)
            return cb(error);
        }
    });
}
   
module.exports.__patchNetwork = new function() {
    var oldrequestToXSUAA = _requestToNetwork;

    this.patch = function(fnc) {
        if(typeof fnc === 'function') {
            debugTrace("patch XSUAA communication to another function");
            _requestToNetwork = fnc;
        } else {
            if(_requestToNetwork !== oldrequestToXSUAA) {
                debugTrace("patch XSUAA communication to original function");
                _requestToNetwork = oldrequestToXSUAA;
            }
        }
    }
}
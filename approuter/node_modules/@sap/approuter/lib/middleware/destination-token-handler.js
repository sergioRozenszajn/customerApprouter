'use strict';
var destinationUtils = require('../../lib/utils/destination-utils');
var tokenUtils = require('../../lib/utils/token-utils');
var jwtDecode  = require('jwt-decode');
var expiresAt  = require('../passport/utils').getExpiresAt;
var validators = require('../configuration/validators');
const clientCertificateUtils = require('../utils/client-certificate-utils');
var self = module.exports = {

  retrieveDestination: function (options, cb){
    self.replaceUserToken(options, function(err, userExchangeToken) {
      if (err) {
        return cb(err);
      }
      var tokenDecoded;
      var userExchangeTokenExpiresAt;
      var destinationName = options.destinationName;
      var accessToken = userExchangeToken && userExchangeToken.access_token ? userExchangeToken.access_token : userExchangeToken;
      destinationUtils.findDestination(destinationName, accessToken, options, function (err, destinationLookUpResult){
        if (err){
          return cb(err);
        }
        try {
          if (!destinationLookUpResult || !destinationLookUpResult.destinationConfiguration) {
            return cb('Cannot get destination configuration for destination ' + destinationName);
          }
          if (destinationLookUpResult.authTokens && destinationLookUpResult.authTokens[0].hasOwnProperty('error')) {
            return cb(destinationLookUpResult.authTokens[0].error);
          }
          if (destinationLookUpResult.authTokens) {
            var authTokenExpiresIn = destinationLookUpResult.authTokens[0].expires_in;
            destinationLookUpResult.authTokens[0].expireDate = destinationLookUpResult.authTokens[0].expires_in ? expiresAt(authTokenExpiresIn).getTime() : 0;
          }
          var result = {};
          if (userExchangeToken) {
            tokenDecoded = jwtDecode(userExchangeToken);
            userExchangeTokenExpiresAt = expiresAt(tokenDecoded.exp - tokenDecoded.iat).getTime();
            result.userExchangeToken = {token: userExchangeToken, expireDate: userExchangeTokenExpiresAt};
          }
          var destinations = [destinationLookUpResult.destinationConfiguration];
          destinationUtils.normalizeDestinationProperties(destinations);
          validators.validateDestinations(destinations);
          destinationUtils.adjustDestinationProperties(destinations);
          result.destination = destinations[0];
          result.expireDate = destinationLookUpResult.authTokens && destinationLookUpResult.authTokens[0].expireDate;
          if (options.dynamicDestination && !result.destination.dynamicDestination){
            return cb('Destination ' + destinationName + ' is not defined as a dynamic destination in destination service, configure additional property HTML5.DynamicDestination true');
          }
          result.authToken = destinationLookUpResult.authTokens ? destinationLookUpResult.authTokens[0] : null;
          const certificates = clientCertificateUtils.getClientCertificates(destinationLookUpResult);
          if (certificates && certificates.clientCertifacate){
            result.destination.clientCertifacate = certificates.clientCertifacate;
          }
          if (certificates && certificates.trustCertifacate){
            result.destination.trustCertifacate = certificates.trustCertifacate;
          }
          return cb(null, result);
        } catch (error){
          return cb(error);
        }
      });
    });
  },

  isDestinationServiceFlow: function (internalUrl){
    if (!internalUrl || !internalUrl.route || !internalUrl.route.destination || !internalUrl.destination ||
        internalUrl.destination.url  !== 'DESTINATION_URL_PLACEHOLDER'){
      return false;
    }
    return true;
  },

  replaceUserToken: function (options, cb){
    var session = options.session;
    if (!session || !session.user){
      return cb(null);
    }
    shouldRequestUserExchangeToken (session, options.destinationKey,function(err, askForToken){
      if (err) {
        return cb(err);
      }
      if (!askForToken) {
        var userExchangeToken = options.destinationKey && session.user.destinationKey && session.user.destinationKey[options.destinationKey]
            ? session.user.destinationKey[options.destinationKey].destinationUserExchangeToken.token : session.user.destinationUserExchangeToken.token;
        return cb(null, userExchangeToken);
      }
      var externalServiceCredentials;
      if (options.destinationKey && options.app && options.app.services[options.destinationKey]){
        externalServiceCredentials = options.app.services[options.destinationKey].credentials;
        externalServiceCredentials.url = externalServiceCredentials.tokenServiceURL;
        externalServiceCredentials.clientid = externalServiceCredentials.clientId;
        externalServiceCredentials.clientsecret = externalServiceCredentials.clientSecret;
      } else {
        externalServiceCredentials = destinationUtils.getDestinationServiceCredentials();
      }
      var jwt = options.jwt;
      if (!jwt){
        jwt = options.session.user.token.accessToken;
      }
      return tokenUtils.exchangeToken(jwt,externalServiceCredentials, cb);
    });
  },
  addDestinationHeaders : function (req){
    if (req.headers && req.internalUrl && req.internalUrl.destination){
      const escapeHeaders = Object.keys(req.headers);
      for (const destinationKey in req.internalUrl.destination) {
        if (destinationKey.startsWith('uRL.headers')){
          const headerKey = destinationKey.split('.')[2];
          if (headerKey && !escapeHeaders.includes(headerKey)){
            req.headers[headerKey] = req.internalUrl.destination[destinationKey];
          }
        }
      }
    }
    return req;
  }
};

function shouldRequestUserExchangeToken(session,destinationKey, cb){
  var destinationTokensCache = destinationKey && session.user.destinationKey && session.user.destinationKey[destinationKey]
      ? session.user.destinationKey[destinationKey].destinationUserExchangeToken : session.user.destinationUserExchangeToken;

  // check the expiration of destinationUserExchangeToken
  if (!destinationTokensCache || (!destinationTokensCache.token || destinationTokensCache.expireDate < Date.now())) {
    return cb (null, true);
  }
  return cb (null, false);
}
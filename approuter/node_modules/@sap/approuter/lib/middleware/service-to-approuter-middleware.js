'use strict';
const jwtDecode = require('jwt-decode');
const passportUtils = require('../passport/utils');
const xsenv = require('@sap/xsenv');
const xssec = require('@sap/xssec');
const pathUtil = require('../utils/path-util');
const logger = require('../utils/logger');

module.exports = function (req, res, next) {

  let auth = req.headers && req.headers['x-approuter-authorization'];

  if (!auth) {
    return next();
  }
  const tracer = req.loggingContext.getTracer(__filename);
  tracer.debug('Incoming request contains x-approuter-authorization header');

  if (req.routerConfig && pathUtil.isPublicPath(req)) {
    tracer.debug('Request to public route with source %s contains x-approuter-authorization header ', req.internalUrl.route.source);
  }

  const authArr = auth.split(' ');
  const type = authArr[0];
  const value = authArr[1];
  try {
    const token = value;
    const ownUAACredentials = xsenv.serviceCredentials({tag: 'xsuaa'});
    xssec.createSecurityContext(token, ownUAACredentials, function (err) {
      let error;
      if (err) {
        tracer.error('Token validation failed for request url %s', req.url);
        err.status = 401;
        writeAuditLog(req, token, err, tracer, ownUAACredentials, next);
      } else if (type.toLowerCase() !== 'bearer') {
        tracer.info('x-approuter-authorization header is not a Bearer token');
        error = new Error('x-approuter-authorization header is not a Bearer token');
        error.status = 400;
        writeAuditLog(req, token, error, tracer, ownUAACredentials, next);
      } else {
        const tokenDecoded = jwtDecode(value);
        const tokenContext = {
          accessToken: value,
          expiresIn: Date.now() + 600000,
          scope: tokenDecoded.scope
        };
        const user = passportUtils.getUserProperties(tokenContext);

        req.session = {
          jwtRefreshStarted: true,
          user: user,
          req: req,
          reload: function (cb) {
            cb();
          },
          save: function () {
          },
          touch: function () {
          }
        };
        tracer.info('Session created successfully');
        return next();
      }
    });
  } catch (error) {
    tracer.info('service-to-approuter-middleware: failed');
    next(error);
  }

};

function writeAuditLog(req, token, error, tracer, ownUAACredentials, next) {
  let auditlogCredentials;
  try {
    auditlogCredentials = xsenv.serviceCredentials({tag: 'auditlog'});
  } catch (error) {
    auditlogCredentials = null;
  }
  let IP = (auditlogCredentials) ? req.headers['x-forwarded-host'] : '******';
  const authorization = (auditlogCredentials) ? token : '******';
  const sourceOfRoute = req.internalUrl ? req.internalUrl.route.source : req.url;
  const message = error.message + '- Source of route: ' + sourceOfRoute + ', IP: ' + IP + ', x-approuter-authorization: ' + authorization;

  const loggingData = {};
  loggingData.user = 'Service to Approuter request';
  loggingData.tenantid = getTenant(req, ownUAACredentials);
  logger.writeToAuditLog(req, loggingData, message, function (err) {
    if (err) {
      req && req.logger && req.logger.error('Error occurred when writing to audit log. Error: %s', err.message);
    }
    return next(error);
  });
}

function getTenant(req, ownUAACredentials) {
  let tenant = ownUAACredentials.identityzone;
  let tokenDecoded;
  if (req.headers['x-subscriber-tenant']) {
    tenant = req.headers['x-subscriber-tenant'];
  } else {
    try {
      tokenDecoded = jwtDecode(req.headers['x-approuter-authorization']);
    } catch (err) {
      req && req.logger && req.logger.error('Failed to decode token', err.message);
    }
    if (tokenDecoded && tokenDecoded.ext_attr && tokenDecoded.ext_attr.zdn) {
      tenant = tokenDecoded.ext_attr.zdn;
    }
  }
  return tenant;
}

'use strict';

var loggingUtils = require('./logger');
var logger = loggingUtils.getLogger('/Subscription');
var urlUtils = require('../utils/url-utils');
var vcapUtils = require('../utils/vcap-utils');
var configUtils = require('../utils/configuration-utils');
var xsenv = require('@sap/xsenv');
var xssec = require('@sap/xssec');
var uaaUtils = require('./uaa-utils');
var iasUtils = require('./ias-utils');
var urijs = require('urijs');
var pki = require('node-forge').pki;
var bsUtils = require('../utils/business-service-utils');

const sapCloudServiceParam = 'sap.cloud.service';
const applicationPathParam = 'application.path';
const PROCESS_TYPE_SAAS_REG_GET_DEPENDENCIES     = 'saasRegistryGetDependencies';
const PROCESS_TYPE_SAAS_REG_ON_SUBSCRIPTION      = 'saasRegistryOnSubscription';
const PROCESS_TYPE_SAAS_REG_ON_DEL_SUBSCRIPTION  = 'saasRegistryOnDeleteSubscription';
const PROCESS_TYPE_SMS_GET_DEPENDENCIES          = 'smsGetDependencies';
const PROCESS_TYPE_SMS_ON_SUBSCRIPTION           = 'smsOnSubscription';
const PROCESS_TYPE_SMS_ON_DEL_SUBSCRIPTION       = 'smsOnDeleteSubscription';

exports.getSaaSRegistryDependencies = getSaaSRegistryDependencies;
exports.getSMSDependencies = getSMSDependencies;
exports.checkScopes = checkScopes;
exports.checkCertificate = checkCertificate;
exports.getSaaSRegistryApplicationUrl = getSaaSRegistryApplicationUrl;
exports.getSMSApplicationUrl = getSMSApplicationUrl;
exports.getError = getError;
exports.getSubscriptionProcessType = getSubscriptionProcessType;
exports.getSaaSRegistryCallbackPath = getSaaSRegistryCallbackPath;
exports.getSMSCallbackPath = getSMSCallbackPath;

function getSubscriptionProcessType(req, saasRegistryCredentials, smsCredentials) {
  if (!saasRegistryCredentials && !smsCredentials) {
    return null;
  }
  if (smsCredentials) {
    let callBackPath = getSMSCallbackPath(smsCredentials);
    if (callBackPath.getDependenciesPrefix !== '' && req.url.startsWith(callBackPath.getDependenciesPrefix) && req.method === 'GET') {
      return PROCESS_TYPE_SMS_GET_DEPENDENCIES;
    }
    if (req.url.startsWith(callBackPath.onSubscriptionPrefix) && req.method === 'PUT') {
      return PROCESS_TYPE_SMS_ON_SUBSCRIPTION;
    }
    if (req.url.startsWith(callBackPath.onSubscriptionPrefix) && req.method === 'DELETE') {
      return PROCESS_TYPE_SMS_ON_DEL_SUBSCRIPTION;
    }
  }
  if (saasRegistryCredentials) {
    let callBackPath = getSaaSRegistryCallbackPath(saasRegistryCredentials);
    if (callBackPath.getDependenciesPath !== '' && req.url.startsWith(callBackPath.getDependenciesPath) && req.method === 'GET') {
      return PROCESS_TYPE_SAAS_REG_GET_DEPENDENCIES;
    }
    if (req.url.startsWith(callBackPath.onSubscriptionPrefix) && req.method === 'PUT') {
      return PROCESS_TYPE_SAAS_REG_ON_SUBSCRIPTION;
    }
    if (req.url.startsWith(callBackPath.onSubscriptionPrefix) && req.method === 'DELETE') {
      return PROCESS_TYPE_SAAS_REG_ON_DEL_SUBSCRIPTION;
    }
  }
  return null;
}

function checkScopes(req, cb){
  let sapCloudService = urlUtils.getQueryParam(req,sapCloudServiceParam);
  let ownCredentials = null;
  let token = null;
  try {
    token = getToken(req);
  } catch (err){
    return cb(err);
  }
  if (sapCloudService) {
    bsUtils.getDestinationCredentialsBySapCloudService(req,sapCloudService, (err, result) => {
      if (err || !result) {
        return cb('Failed to get destination credentials by sapCloudService ' + sapCloudService + ' ' + err);
      }
      ownCredentials = result.credentials.uaa;
      doCheckToken(token, ownCredentials,cb);
    });
  } else {
    ownCredentials = xsenv.serviceCredentials({label: 'xsuaa'});
    doCheckToken(token, ownCredentials,cb);
  }
}

function checkCertificate(req,credentials, cb){
  let message;
  let clientCertificate = req.headers[process.env.CLIENT_CERTIFICATE_HEADER_NAME || 'x-forwarded-client-cert'];
  if (!clientCertificate){
    message = 'Missing certificate for subscription manager callback in SMS subscription';
    logger.error(message);
    let error = getError(message, 401);
    return cb(error);
  }

  if (!credentials.callback_certificate_subject){
    message = 'Missing certificate subject for subscription manager callback in the call to create subscription';
    logger.error(message);
    let error = getError(message, 401);
    return cb(error);
  }

  let subj;
  try {
    subj = typeof credentials.callback_certificate_subject === 'string' ?
      JSON.parse(credentials.callback_certificate_subject) : credentials.callback_certificate_subject;
  } catch (err){
    message = 'failed to parse certificate subject in SMS subscription';
    logger.error(message);
    return cb(getError(message + ' ' + err, 500));
  }

  clientCertificate = decodeURIComponent(clientCertificate);
  const certStr = (clientCertificate.indexOf('CERTIFICATE') === -1) ? '-----BEGIN CERTIFICATE-----\n' + clientCertificate + '\n-----END CERTIFICATE-----' : clientCertificate;
  var crt;
  try {
    crt = pki.certificateFromPem(certStr);
  } catch (err){
    message = 'Failed to parse certificate';
    logger.error(message);
    return cb(getError(message + ' ' + err, 500));
  }

  var certCN = crt.subject.getField('CN').value;
  var certL = crt.subject.getField('L').value;
  var certOUN = crt.subject.attributes.filter((item) => item.shortName === 'OU').map((item) => { return item.value; });
  var certON = crt.subject.getField('O').value;
  var certC = crt.subject.getField('C').value;

  if (certCN !== subj.CN) {
    message = 'Error - failed to validate certificate in SMS subscription, invalid common name ' + certCN;
    logger.error(message);
    return cb(getError(message, 403));
  }
  if (certL !== subj.L) {
    message = 'Error - failed to validate certificate in SMS subscription, invalid locality name ' + certL ;
    logger.error(message);
    return cb(getError(message, 403));
  }
  if (certON !== subj.O) {
    message = 'Error - failed to validate certificate in SMS subscription, invalid organization name ' + certON;
    logger.error(message);
    return cb(getError(message, 403));
  }
  if (certC !== subj.C) {
    message = 'Error - failed to validate certificate in SMS subscription, invalid country name ' + certC ;
    logger.error(message);
    return cb(getError(message, 403));
  }

  var oun1 = certOUN.sort();
  var oun2 = subj.OU;

  if (!Array.isArray(oun1) &&
      Array.isArray(oun2) &&
      oun1.length === oun2.length &&
      oun1.every((val, index) => val === oun2[index])){
    message = 'Error - failed to validate certificate in SMS subscription, invalid organization unit names ' + certOUN ;
    logger.error(message);
    return cb(getError(message, 403));
  }
  cb();
}

function findCallbackScope(ctx){
  if (process.env.SAAS_APPROUTER){
    return true;
  } else {
    return ctx.checkLocalScope('Callback');
  }
}

function getToken (req){
  var authorization = req.headers.authorization;
  if (!authorization) {
    logger.error('Missing Authorization header');
    throw getError('Missing Authorization header', 401);
  }
  var parts = authorization.split(' ');
  if (parts.length < 2) {
    logger.error('Invalid Authorization header format');
    throw getError('Invalid Authorization header format', 400);
  }
  var scheme = parts[0];
  var token = parts[1];

  if (scheme.toLowerCase() !== 'bearer') {
    logger.error('Authorization header is not a Bearer token');
    throw getError('Authorization header is not a Bearer token', 401);
  }
  return token;
}

function getSMSApplicationUrl(req,smsCredentials, cb){
  if (!req.body){
    let error = getError('Bad request: Missing body', 400);
    return cb(error);
  }
  const iasTenantHost = req.body.subscriber && req.body.subscriber.tenantHost;
  let subscriberIasTenant = iasTenantHost.substring(0, iasTenantHost.indexOf('.'));
  let subscriberTenant = req.body.subscriber.zoneId + '--' + subscriberIasTenant;

  iasUtils.getIasConfig(req, function (err, iasOptions) {
    if (err) {
      return cb(err);
    }
    if (!iasOptions) {
      return cb('Invalid ias options');
    }
    let approuterHost = urlUtils.getRedirectHost(req).replace('.cert.','.');
    let providerTenant = getTenant(approuterHost);
    approuterHost =  approuterHost.replace(providerTenant, subscriberTenant);
    let proto = req.headers['x-forwarded-proto'] || req.protocol;
    const response = {
      applicationURL: proto + '://' + approuterHost
    };
    cb(null, response);
  });
}

function getSaaSRegistryApplicationUrl(req,cb){
  var error = null;
  if (!req.body){
    error = getError('Bad request: Missing body', 400);
    return cb(error);
  }

  var subdomain = req.body.subscribedSubdomain;
  if (!subdomain) {
    error = getError('Bad request: Missing subscribedSubdomain', 400);
    return cb(error);
  }

  uaaUtils.getUaaConfig(req, function (err, uaaOptions) {
    if (err) {
      return cb(err);
    }
    if (!uaaOptions) {
      return cb('Invalid UAA options');
    }

    if (uaaOptions.tenantmode !== 'shared'){
      error = getError('Tenant mode should be shared', 500);
      return cb(error);
    }
    var proto = req.headers['x-forwarded-proto'] || req.protocol;
    var url = proto + '://' + urlUtils.getRedirectHost(req).replace(uaaOptions.tenant, subdomain);
    var applicationPath = urlUtils.getQueryParam(req,applicationPathParam);
    var sapCloudService = urlUtils.getQueryParam(req,sapCloudServiceParam);
    if (process.env.SAAS_APPROUTER && applicationPath) {
      if (!sapCloudService) {
        return cb(null,urlUtils.join(url,applicationPath));
      }
      bsUtils.getDestinationCredentialsBySapCloudService(req,sapCloudService, (err, result) => {
        if (err || !result) {
          return cb('Failed to get destination credentials by sapCloudService ' + sapCloudService + ' ' + err);
        }
        cb(null, result && result.credentials && result.credentials.destinationId && !applicationPath.startsWith('/') ? urlUtils.join(url,result.credentials.destinationId)
            + '.' + sapCloudService + '.' + applicationPath : urlUtils.join(url,applicationPath));
      });
    } else {
      cb(null, url);
    }
  });
}

function getError(errorStr, status){
  var error = new Error(errorStr);
  error.status = status;
  logger.error(errorStr);
  return error;
}
function getSMSDependencies(req,cb){
  return exports.getSaaSRegistryDependencies(req,cb);
}

function getSaaSRegistryDependencies(req, cb){
  var sapCloudService = urlUtils.getQueryParam(req,sapCloudServiceParam);
  if (process.env.SAAS_APPROUTER && sapCloudService){
    return getSaaSRegistryDependenciesBySapCloudService(sapCloudService,req,cb);
  }
  var dependenciesArray = [];
  var appId = null;
  var appName = null;
  var xsappname = null;
  var services = xsenv.readServices();
  for (var service in services) {
    xsappname = appId = appName = null;
    var svcName = services[service].label;

    var cred = services[service].credentials;
    if (svcName === 'destination' || svcName === 'connectivity'){
      appId = cred.xsappname;
      appName = svcName;
    } else if (cred.saasregistryappname){
      appId = cred.uaa.xsappname;
      appName = cred.saasregistryappname;
    } else if (cred.saasregistryenabled){
      xsappname = cred.uaa.xsappname;
    }
    var obj = null;
    if (appId && appName) {
      obj = {'appId': appId, 'appName': appName};
    } else if (xsappname){
      obj = {'xsappname': xsappname};
    }
    if (obj){
      dependenciesArray.push(obj);
    }
  }
  cb(null,dependenciesArray);
}

function getSaaSRegistryCallbackPath(credentials){
  var callBackPath = {
    getDependenciesPath: '/callback/v1.0/dependencies',
    onSubscriptionPrefix: '/callback/v1.0/tenants'
  };
  if (!credentials){
    credentials = vcapUtils.getServiceCredentials({ label: 'saas-registry' });
  }
  if (!credentials){
    return callBackPath;
  }
  try {
    if (credentials.appUrls) {
      var appUrlsJson = JSON.parse(credentials.appUrls);
      var parsedUrl = urijs.parse(appUrlsJson.getDependencies);
      callBackPath.getDependenciesPath = parsedUrl.path;
      parsedUrl = urijs.parse(appUrlsJson.onSubscription);
      let index = parsedUrl.path.indexOf('/{tenantId}');
      if (index > 0){
        parsedUrl.path = parsedUrl.path.substring(0,index);
      }
      callBackPath.onSubscriptionPrefix = parsedUrl.path;
    }
  } catch (e){
    return callBackPath;
  }
  return callBackPath;
}

function getSMSCallbackPath(credentials){
  var callBackPath = {
    getDependenciesPrefix: '/v1.0/callback/zones',
    onSubscriptionPrefix: '/v1.0/callback/zones'
  };
  if (!credentials){
    credentials = vcapUtils.getServiceCredentials({ label: 'subscription-manager' });
  }
  if (!credentials){
    return callBackPath;
  }
  try {
    var appUrlsJson = typeof credentials.app_urls === 'string' ? JSON.parse(credentials.app_urls) : credentials.app_urls;
    var parsedUrl = urijs.parse(appUrlsJson.dependenciesCallbacks.url);
    let index = parsedUrl.path.indexOf('/{zoneId}');
    if (index > 0){
      parsedUrl.path = parsedUrl.path.substring(0,index);
    }
    callBackPath.getDependenciesPrefix = parsedUrl.path;
    parsedUrl = urijs.parse(appUrlsJson.subscriptionCallbacks.url);
    index = parsedUrl.path.indexOf('/{zoneId}');
    if (index > 0){
      parsedUrl.path = parsedUrl.path.substring(0,index);
    }
    callBackPath.onSubscriptionPrefix = parsedUrl.path;
  } catch (e){
    logger.error('Failed to parse sms app_urls' + e);
    throw getError('Failed to parse sms app_urls', 500);
  }
  return callBackPath;
}

function getTenant(approuterHost){
  let tenant = null;
  if (process.env.TENANT_HOST_PATTERN){
    let tenantHostPattern = configUtils.constructRegExp(process.env.TENANT_HOST_PATTERN);
    tenant = uaaUtils.retrieveTenantFromURL(approuterHost, tenantHostPattern);
  }
  return tenant;
}
function getSaaSRegistryDependenciesBySapCloudService(sapCloudService,req, cb){
  bsUtils.getDestinationCredentialsBySapCloudService(req,sapCloudService, (err, result, relatedBusinessServicesXsappNames) => {
    if (err){
      return cb('Failed to get destination credentials by sapCloudService ' + sapCloudService + ' ' + err);
    }
    let dependencies = [];
    if (!result || !result.credentials){
      return cb(null,dependencies);
    }
    if (result.credentials['html5-apps-repo'] && result.credentials['html5-apps-repo']['xsappname']){
      let xsAppnames = [];
      if (result.credentials['html5-apps-repo']['xsappname'].indexOf(',') > -1) {
        xsAppnames = result.credentials['html5-apps-repo']['xsappname'].split(',');
      } else {
        xsAppnames.push(result.credentials['html5-apps-repo']['xsappname']);
      }
      xsAppnames.forEach((xsappname) => {
        if (xsappname !== 'undefined'){
          dependencies.push({'xsappname': xsappname});
        }
      });
    }
    if (result.credentials['destinationXsappname']){
      dependencies.push({'xsappname': result.credentials['destinationXsappname']});
    }
    if (relatedBusinessServicesXsappNames.length > 0){
      relatedBusinessServicesXsappNames.forEach((xsappname) => {
        dependencies.push({'xsappname':xsappname});
      });
    }
    logger.info('Returned dependencies ' + JSON.stringify(dependencies));
    cb(null,dependencies);
  });
}

function doCheckToken(token, ownCredentials, cb){
  try {
    xssec.createSecurityContext(token, ownCredentials, function (err, ctx) {
      if (err) {
        cb(err, null);
      } else if (!findCallbackScope(ctx)) {
        logger.error('Missing the expected scope - Callback - in the call to create subscription');
        var error = getError('Forbidden - Missing the expected scope', 403);
        cb(error, null);
      } else {
        cb(null, true);
      }
    });
  } catch (error) {
    cb (error);
  }
}

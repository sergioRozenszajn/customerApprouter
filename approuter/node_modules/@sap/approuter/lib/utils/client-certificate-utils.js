'use strict';
const { toPem } = require('jks-js');
const forge = require('node-forge');

const KeySeparator = pem => {
  const separator = pem.match(/([-]+END [^\\s]+ PRIVATE KEY[-]+)|([-]+END PRIVATE KEY[-]+)/);
  return separator ? separator[0] : undefined;
};

const decodeTextFormat = (content ,password = '') => {
  const pem = Buffer.from(content,'base64').toString('ascii');
  const separator = KeySeparator(pem);
  if (separator){
    const separated = pem.split(separator);
    const cert = separated[1];
    let key = separated[0] + separator;
    if (password){
      try {
        const decrypted = forge.pki.decryptRsaPrivateKey(key, password);
        key = forge.pki.privateKeyToPem(decrypted);
      }
      catch (error){
        throw new Error(`Failed to decode text certificate ${error.message}`);
      }
    }
    return  { cert, key };
  }
};

const decodeBinaryFormat = (content, password) => {
  try {
    const buffer = Buffer.from(content,'base64');
    const pem = toPem(buffer, password);
    const { cert ,key }  = Object.values(pem)[0];
    return { cert, key };
  }
  catch (error) {
    throw new Error(`Failed to decode binary certificate ${error.message}`);
  }
};

const  decodeCertificate = (certificateObj, password) => {
  const {  Content , Name } = certificateObj;
  const  fileExtension =  Name.split('.').pop();
  if (fileExtension !== 'pem') {
    return  decodeBinaryFormat(Content,password);
  }
  return decodeTextFormat(Content,password);
};

const getClientCertificates =  destinationLookUpResult  => {
  if (!destinationLookUpResult.certificates){
    return null;
  }
  const { KeyStoreLocation, TrustStoreLocation, TrustStorePassword, KeyStorePassword } = destinationLookUpResult.destinationConfiguration ;
  const { certificates } =  destinationLookUpResult ;
  const clientCertificates = {};

  certificates.forEach((certificate) => {
    let certificateType;
    if (certificate['Name'] === KeyStoreLocation){
      certificateType = 'clientCertifacate';
    }
    else if (certificate['Name'] === TrustStoreLocation){
      certificateType = 'trustCertifacate';
    }

    if (certificateType){
      const password = certificateType === 'clientCertifacate' ? KeyStorePassword : TrustStorePassword ;
      clientCertificates[certificateType] = decodeCertificate(certificate,password);
    }
  });
  return clientCertificates ;
};

const  escape = destination => {
  return (destination.Authentication === 'ClientCertificateAuthentication' && destination.KeyStoreLocation) || destination.TrustStoreLocation;
};

module.exports = {
  getClientCertificates,
  escape,
  decodeBinaryFormat,
  KeySeparator,
  decodeTextFormat,
};

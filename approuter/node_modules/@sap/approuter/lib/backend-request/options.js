'use strict';

var http = require('http');
var https = require('https');
var agents = require('./agents');
var backendHeaders = require('./headers');
var urlUtils = require('../utils/url-utils');
var traceUtil = require('../utils/trace-util');
var stripClientCookies = require('../middleware/strip-client-cookies');
var tough = require('tough-cookie');
var passportUtils = require('../passport/utils');
var _ = require('lodash');
var tracer = require('../utils/logger').getTracer(__filename);


exports.getLogoutRequest = function (req, accessToken, destination, xsAppDestConfig, session) {
  var method = xsAppDestConfig.logoutMethod || 'POST';
  var logoutUrl = urlUtils.join(destination.url, xsAppDestConfig.logoutPath);
  var headers = backendHeaders.getHeaders(req, accessToken, destination);
  module.exports.getBackendCookies(req,session, headers, destination);
  return getRequestImpl(method, urlUtils.parse(logoutUrl), headers, destination, null,session);
};

exports.getBackendCookies = function(req,session, headers, destination){
  if (session && session._cookieJar) {
    if (req){
      stripClientCookies(req, req.app.get('cookieName'));
    }
    var jar = _.cloneDeep(session._cookieJar); // see tough-cookie issue #59
    tough.CookieJar.deserialize(jar, function (err, cookieJar) {
      if (err) {
        return;
      }
      cookieJar.getCookieString(destination.url, function(err, cookies){
        if (err) {
          return;
        }
        if (cookies) {
          headers.cookie = headers.cookie ? headers.cookie + '; ' + cookies : cookies;
        }
      });
    });
  }
};

exports.getRequest = function (req, accessToken) {
  let headers = backendHeaders.getHeaders(req, accessToken);
  return getRequestImpl(req.method, req.internalUrl, headers, req.internalUrl.destination, tracer, req.session);
};

function getRequestImpl(method, parsedUrl, headers, destination, tracer, session) {
  var proxyUri = exports.buildProxyUri(destination);
  var opts = {
    method: method,
    protocol: parsedUrl.protocol,
    hostname: parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.path,
    agent: agents.get(parsedUrl.protocol, proxyUri, destination.proxyType === 'OnPremise'),
    rejectUnauthorized: !(destination.strictSSL === false),
    headers: headers
  };
  let oauthOptions = session && session.user && session.user.token && session.user.token.oauthOptions;
  let certificate = destination && destination.clientCertifacate ? destination.clientCertifacate.cert : oauthOptions && oauthOptions.certificate;
  // if (certificate) {
  //   let rootCertificate = passportUtils.getHttpCertificates(certificate);
  //   opts.cert = rootCertificate.cert;
  //   opts.key  = (destination && destination.clientCertifacate && destination.clientCertifacate.key)
  //       ? destination.clientCertifacate.key : oauthOptions.key;
  // }
  if(destination && destination.clientCertifacate ){
    opts.pfx =  destination.clientCertifacate.buffer;
    opts.passphrase = destination.clientCertifacate.password;
  }

  if (headers.host) { // So socket does not use host header as target (allows differing host header)
    opts['servername'] = parsedUrl.hostname;
  }
  var useSSL = /^https/i.test(opts.protocol);
  let trustCertifacate = destination && destination.trustCertifacate && destination.trustCertifacate.cert;
  let ca = opts.agent.options && opts.agent.options.ca;
  if (useSSL && (trustCertifacate || ca)) { // fixes leaking ssl sockets in node
    opts.ca = trustCertifacate || ca;
  }
  if (tracer) {
    traceUtil.traceBackendRequest(tracer, parsedUrl.href, opts);
  }
  return useSSL ? https.request.bind(undefined, opts) : http.request.bind(undefined, opts);
}

exports.buildProxyUri = function (destination) {
  var proxyHost = destination.proxyHost;
  var proxyPort = destination.proxyPort;
  if (!proxyHost) {
    return;
  }
  var hasProtocol = /^https?:\/\//i.test(proxyHost);
  if (hasProtocol) {
    return proxyHost + ':' + proxyPort;
  }
  return 'http://' + proxyHost + ':' + proxyPort;
};

